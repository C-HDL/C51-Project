C51 COMPILER V9.01   WIFI_CONTROL                                                          03/08/2024 00:02:56 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE WIFI_CONTROL
OBJECT MODULE PLACED IN .\Obj\wifi_control.obj
COMPILER INVOKED BY: E:\keilc51\C51\BIN\C51.EXE App_Demo\wifi_control.c BROWSE INCDIR(.\App\24c02;.\App\iic;.\App\key;.\
                    -App\smg;.\Public;.\App\ds18b20;.\App_Demo) DEBUG OBJECTEXTEND PRINT(.\Obj\wifi_control.lst) OBJECT(.\Obj\wifi_control.ob
                    -j)

line level    source

   1          #include "wifi_control.h"
   2          #include "ds18b20.h"
   3          #include "uart.h"
   4          #include "smg.h"
   5          #include "timer.h"
   6          
   7          //定义LED1管脚
   8          sbit LED1=P2^0;
   9          sbit LED2=P2^1;
  10          sbit LED3=P2^2;
  11          
  12          //定义WIFI控制命令
  13          #define LED1_ON_CMD                     '1'
  14          #define LED1_OFF_CMD            '2'
  15          #define LED2_ON_CMD                     '3'
  16          #define LED2_OFF_CMD            '4'
  17          #define LED3_ON_CMD                     '5'
  18          #define LED3_OFF_CMD            '6'
  19          
  20          
  21          //ESP8266 WIFI发送AT指令
  22          //pbuf：AT指令，字符串格式，如："AT"
  23          void ESP8266_SendCmd(u8 *pbuf)
  24          {
  25   1              while(*pbuf!='\0') //遇到空格跳出循环   
  26   1              {
  27   2                      UART_SendData(*pbuf);
  28   2                      delay_10us(5);
  29   2                      pbuf++; 
  30   2              }
  31   1              delay_10us(5);
  32   1              UART_SendData('\r');//回车
  33   1              delay_10us(5);
  34   1              UART_SendData('\n');//换行
  35   1              delay_ms(1000);
  36   1      }
  37          
  38          //ESP8266 WIFI发送数据到APP
  39          //pbuf：数据
  40          void ESP8266_SendData(u8 *pbuf)
  41          {
  42   1              ESP8266_SendCmd("AT+CIPSEND=0,7");
  43   1              while(*pbuf!='\0') //遇到空格跳出循环   
  44   1              {
  45   2                      UART_SendData(*pbuf);
  46   2                      delay_10us(5);
  47   2                      pbuf++; 
  48   2              }
  49   1              UART_SendData('\n');//换行      
  50   1      //      delay_ms(10);
  51   1      }
  52          
  53          //ESP8266-WIFI模块工作模式初始化
C51 COMPILER V9.01   WIFI_CONTROL                                                          03/08/2024 00:02:56 PAGE 2   

  54          void ESP8266_ModeInit(void)
  55          {
  56   1              ESP8266_SendCmd("AT+CWMODE=2");//设置路由器模式 1 staTIon模式 2 AP点 路由器模式 3 station+AP混合模式
  57   1              ESP8266_SendCmd("AT+CWSAP=\"PRECHIN\",\"prechin168\",11,0"); //设置WIFI热点名及密码
  58   1              ESP8266_SendCmd("AT+CIPAP=\"192.168.4.1\"");
  59   1      //      ESP8266_SendCmd("AT+RST");//重新启动wifi模块
  60   1      //      delay_ms(2000);
  61   1              ESP8266_SendCmd("AT+CIPMUX=1"); //开启多连接模式，允许多个各客户端接入
  62   1              ESP8266_SendCmd("AT+CIPSERVER=1,8080"); //启动TCP/IP 端口为8080 实现基于网络控制        
  63   1      } 
  64          
  65          //WIFI控制初始化
  66          void wifi_control_init(void)
  67          {
  68   1              UART_Init();
  69   1              time0_init();
  70   1              ds18b20_init();//初始化DS18B20
  71   1              ESP8266_ModeInit();
  72   1              ES=1;//允许串口中断
  73   1      }
  74          
  75          //WIFI控制
  76          void wifi_control(void)
  77          {
  78   1              u16 i=0;
  79   1              int temp_value;
  80   1              u8 temp_buf[5];
  81   1              u8 wifi_send_buf[7];
  82   1      
  83   1              while(1)
  84   1              {
  85   2                      i++;
  86   2                      if(i%50==0)//间隔一段时间读取温度值，间隔时间要大于温度传感器转换温度时间
  87   2                              temp_value=ds18b20_read_temperture()*10;//保留温度值小数后一位
  88   2                      if(temp_value<0)//负温度
  89   2                      {
  90   3                              temp_value=-temp_value;
  91   3                              temp_buf[0]=0x40;//显示负号
  92   3                              wifi_send_buf[0]='-';   
  93   3                      }
  94   2                      else
  95   2                      {
  96   3                              temp_buf[0]=0x00;//不显示
  97   3                              wifi_send_buf[0]='+';
  98   3                      }               
  99   2                      temp_buf[1]=gsmg_code[temp_value/1000];//百位
 100   2                      temp_buf[2]=gsmg_code[temp_value%1000/100];//十位
 101   2                      temp_buf[3]=gsmg_code[temp_value%1000%100/10]|0x80;//个位+小数点
 102   2                      temp_buf[4]=gsmg_code[temp_value%1000%100%10];//小数点后一位
 103   2                      smg_display(temp_buf,4);
 104   2                      if(i%100==0)
 105   2                      {
 106   3                              wifi_send_buf[1]=temp_value/1000+0x30;
 107   3                              wifi_send_buf[2]=temp_value%1000/100+0x30;
 108   3                              wifi_send_buf[3]=temp_value%1000%100/10+0x30;
 109   3                              wifi_send_buf[4]='.';
 110   3                              wifi_send_buf[5]=temp_value%1000%100%10+0x30;
 111   3                              wifi_send_buf[6]='\0';
 112   3                              ESP8266_SendData(wifi_send_buf);//通过串口发送温度数据到APP     
 113   3                      }               
 114   2              }       
 115   1      }
C51 COMPILER V9.01   WIFI_CONTROL                                                          03/08/2024 00:02:56 PAGE 3   

 116          
 117          //串口中断服务函数
 118          //接收手机APP发送的信号后控制板载资源
 119          void UART_IRQn() interrupt 4
 120          {
 121   1              static u8 i=0;
 122   1      
 123   1              if(RI)
 124   1              {
 125   2                      RI=0;
 126   2                      UART_RX_BUF[i]=SBUF;//读取接收到的数据
 127   2                      if(UART_RX_BUF[0]=='+')i++;
 128   2                      else i=0;
 129   2                      if(i==10)
 130   2                      {
 131   3                              i=0;
 132   3                              //WIFI控制
 133   3                              if(UART_RX_BUF[9]==LED1_ON_CMD)
 134   3                                      LED1=1;
 135   3                              else if(UART_RX_BUF[9]==LED1_OFF_CMD)
 136   3                                      LED1=0; 
 137   3                              if(UART_RX_BUF[9]==LED2_ON_CMD)
 138   3                                      LED2=1;
 139   3                              else if(UART_RX_BUF[9]==LED2_OFF_CMD)
 140   3                                      LED2=0; 
 141   3                              if(UART_RX_BUF[9]==LED3_ON_CMD)
 142   3                                      LED3=1;
 143   3                              else if(UART_RX_BUF[9]==LED3_OFF_CMD)
 144   3                                      LED3=0;         
 145   3                      }                       
 146   2              }       
 147   1      }
 148          
 149          void time0() interrupt 1 //定时器0中断函数
 150          {
 151   1              static u16 i;//定义静态变量i
 152   1              TH0=0XFC; //给定时器赋初值，定时1ms
 153   1              TL0=0X18;
 154   1              if(LED1==1)
 155   1              {
 156   2                      i++;
 157   2                      if(i==5000)
 158   2                      {
 159   3                              i=0;
 160   3                              LED1=0;
 161   3                      }
 162   2              }
 163   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    650    ----
   CONSTANT SIZE    =    119    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
