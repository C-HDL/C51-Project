C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NODE1
OBJECT MODULE PLACED IN node1.OBJ
COMPILER INVOKED BY: E:\keilc51\C51\BIN\C51.EXE node1.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          #define uchar   unsigned char   //宏定义
   5          #define uint    unsigned int    //宏定义
   6          
   7          #define N_can   13      //N_can代表一帧字节数
   8          
   9          bit left_flag = 0;
  10          
  11          uchar TX_buffer_1[13]; //接收的13个字节数据（//发送的数据）
  12          uchar RX_buffer_1[13]; //接收的13个字节数据
  13          
  14          sbit SJA_CS  = P2^0; //SJA1000片选管脚，低电平有效
  15          sbit SJA_RST = P2^7;//SJA1000复位管脚
  16          
  17          sbit left_light = P1^0;//左转向灯
  18          sbit backup_light = P1^1;//倒车灯
  19          sbit frog_light = P1^2;//雾灯
  20          sbit stop_light   = P1^3;//刹车灯
  21          
  22          uchar complete_1;
  23          
  24          bit interrupt_flag_1 = 0;
  25          
  26          /*CAN总线SJA1000寄存器地址定义（用的是PeliCAN模式，扩展帧EFF模式）*/
  27          //xdata ----> 可寻址片外ram (64k地址范围:0000H-FFFFH)
  28          uchar   xdata    MODR     _at_   0xFE00;        // 模式寄存器
  29          uchar   xdata    CMR      _at_   0xFE01;        // 命令寄存器
  30          uchar   xdata    SR           _at_   0xFE02;    // 状态寄存器
  31          uchar   xdata    IR               _at_   0xFE03;        // 中断寄存器
  32          uchar   xdata    IER      _at_   0xFE04;        // 中断使能寄存器
  33          
  34          uchar   xdata    BTR0     _at_   0xFE06;        // 总线定时寄存器0 ；总线波特率的选择
  35          uchar   xdata    BTR1     _at_   0xFE07;        // 总线定时寄存器1 ；总线波特率的选择
  36          uchar   xdata    OCR      _at_   0xFE08;        // 输出控制寄存器       汇编 1a
  37          
  38                  // 验收代码寄存器（16-19）
  39          uchar   xdata    ACR0     _at_   0xFE10;//16;
  40          uchar   xdata    ACR1     _at_   0xFE11;//17;
  41          uchar   xdata    ACR2     _at_   0xFE12;//18;
  42          uchar   xdata    ACR3     _at_   0xFE13;//19;
  43          
  44                  // 验收屏蔽寄存器（20-23）
  45          uchar   xdata    AMR0     _at_   0xFE14;//20;
  46          uchar   xdata    AMR1     _at_   0xFE15;//21;
  47          uchar   xdata    AMR2     _at_   0xFE16;//22;
  48          uchar   xdata    AMR3     _at_   0xFE17;//23;
  49          
  50          uchar   xdata    CDR      _at_   0xFE1F;//31;   // 时钟分频器            C8
  51          uchar   xdata    ALC      _at_   0xFE0B;//11;   // 仲裁丢失捕捉寄存器
  52          uchar   xdata    ECC      _at_   0xFE0C;//12;   // 误码捕捉寄存器
  53          
  54                  // 发送缓冲器地址(16-28)
  55          uchar   xdata    TBSR0    _at_   0xFE10;//16;//TX帧信息
C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 2   

  56          uchar   xdata    TBSR1    _at_   0xFE11;//17;//TX识别码1 (ID.21-ID.28)
  57          uchar   xdata    TBSR2    _at_   0xFE12;//18;//TX识别码2 (ID.13-ID.20)
  58          uchar   xdata    TBSR3    _at_   0xFE13;//19;//TX识别码3 (ID.5-ID.12)
  59          uchar   xdata    TBSR4    _at_   0xFE14;//20;//TX识别码4（高5位是ID.0-ID.4）
  60          uchar   xdata    TBSR5    _at_   0xFE15;//21;//数据1
  61          uchar   xdata    TBSR6    _at_   0xFE16;//22;//数据2
  62          uchar   xdata    TBSR7    _at_   0xFE17;//23;//数据3
  63          uchar   xdata    TBSR8    _at_   0xFE18;//24;//数据4
  64          uchar   xdata    TBSR9    _at_   0xFE19;//25;//数据5
  65          uchar   xdata    TBSR10   _at_   0xFE1A;//26;//数据6
  66          uchar   xdata    TBSR11   _at_   0xFE1B;//27;//数据7
  67          uchar   xdata    TBSR12   _at_   0xFE1C;//28;//数据8
  68          
  69          // 接收缓冲器地址(16-28)
  70          uchar   xdata    RBSR0    _at_   0xFE10;//16;
  71          uchar   xdata    RBSR1    _at_   0xFE11;//17;
  72          uchar   xdata    RBSR2    _at_   0xFE12;//18;
  73          uchar   xdata    RBSR3    _at_   0xFE13;//19;
  74          uchar   xdata    RBSR4    _at_   0xFE14;//20;
  75          uchar   xdata    RBSR5    _at_   0xFE15;//21;
  76          uchar   xdata    RBSR6    _at_   0xFE16;//22;
  77          uchar   xdata    RBSR7    _at_   0xFE17;//23;
  78          uchar   xdata    RBSR8    _at_   0xFE18;//24;
  79          uchar   xdata    RBSR9    _at_   0xFE19;//25;
  80          uchar   xdata    RBSR10   _at_   0xFE1A;//26;
  81          uchar   xdata    RBSR11   _at_   0xFE1B;//27;
  82          uchar   xdata    RBSR12   _at_   0xFE1C;//28;
  83            
  84          /*子函数声明*/
  85          void init_mcu(void);  //MCU初始化
  86          void init_sja1000(void);        //SJA1000初始化
  87          void can_txd(void);  //发送处理函数
  88          void can_rxd(void);      //接收处理函数
  89          void delay(uchar);       //延迟 
  90          
  91          ///////////////////////////////////////////////
  92          //函数：init_mcu
  93          //说明：单片机I/O口初始化
  94          //              主要是各中断寄存器的初始化
  95          //入口：无
  96          //返回：无
  97          ///////////////////////////////////////////////
  98          void init_mcu(void)
  99          {
 100   1          SJA_RST = 0;
 101   1              delay(10);
 102   1          SJA_RST = 1;//CAN总线复位管脚
 103   1              SJA_CS = 0;             //CAN总线片选有效
 104   1          IT0 = 0;    //MCU外部中断INT0设置为 低电平 触发
 105   1          EX0 = 1;    //开MCU外部中断INT0
 106   1          EA = 1;     //开MCU总中断   
 107   1      }
 108          
 109          ///////////////////////////////////////////////
 110          //函数：init_sja1000
 111          //说明：独立CAN控制器SJA1000的初始化
 112          //入口：无
 113          //返回：无
 114          ///////////////////////////////////////////////
 115          void init_sja1000(void)
 116          {
 117   1      //uchar state;
C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 3   

 118   1          uchar ACRR[4];
 119   1          uchar AMRR[4];
 120   1      /*原有代码
 121   1      // 接收代码寄存器                                                            
 122   1          ACRR[0] = 0x20;
 123   1          ACRR[1] = 0x00;
 124   1          ACRR[2] = 0x10;
 125   1          ACRR[3] = 0x00;
 126   1      // 接收屏蔽寄存器
 127   1          AMRR[0] = 0x3f;
 128   1          AMRR[1] = 0Xff;
 129   1          AMRR[2] = 0xf8;
 130   1          AMRR[3] = 0x07;
 131   1      原有代码*/
 132   1              ACRR[0] = 0xff;
 133   1          ACRR[1] = 0x02;
 134   1          ACRR[2] = 0xff;
 135   1          ACRR[3] = 0xff;//接收代码寄存器
 136   1      
 137   1          AMRR[0] = 0xff;
 138   1          AMRR[1] = 0X00;
 139   1          AMRR[2] = 0xff;
 140   1          AMRR[3] = 0xff;//接收屏蔽寄存器，只接收发往本节点的报文
 141   1      
 142   1              MODR  = 0x09;   // 设置MOD.0=1--进入复位模式，以便设置相应的寄存器
 143   1      
 144   1      
 145   1      
 146   1      // 对SJA1000部分寄存器进行初始化设置
 147   1          CDR  = 0xC8;        // CDR为时钟分频器，CDR.3=1--时钟关闭, CDR.7=0---basic CAN, CDR.7=1---Peli CAN
 148   1          BTR0 = 0x01;        // 总线定时寄存器0 ；总线波特率设定
 149   1          BTR1 = 0x1B;        // 总线定时寄存器1 ；总线波特率设定
 150   1          IER  = 0x01;        // IER.0=1--接收中断使能；  IER.1=0--关闭发送中断使能
 151   1          OCR  = 0x1a;        // 配置输出控制寄存器
 152   1          CMR  = 0x04;        // 释放接收缓冲器
 153   1      
 154   1      // 初始化接收代码寄存器
 155   1          ACR0 = ACRR[0];
 156   1          ACR1 = ACRR[1];
 157   1          ACR2 = ACRR[2];
 158   1          ACR3 = ACRR[3]; 
 159   1      
 160   1      // 初始化接收屏蔽寄存器
 161   1          AMR0 = AMRR[0];
 162   1          AMR1 = AMRR[1];
 163   1          AMR2 = AMRR[2];
 164   1          AMR3 = AMRR[3]; 
 165   1      
 166   1              MODR   = 0x08;  //MOD.3=0--双滤波器模式
 167   1      
 168   1      }
 169          
 170          
 171          //      void time0_init()
 172          //{
 173          //      TMOD|=0X10;
 174          //      TH1=0XFC;
 175          //      TL1=0X18;       
 176          //      ET1=1;
 177          //      EA=1;
 178          //      TR1=1;          
 179          //}
C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 4   

 180          
 181          ///////////////////////////////////////////////
 182          //函数：inter1_can_rxd  (外部中断INT0)
 183          //说明：接收数据函数，在中断服务程序中调用
 184          //入口：无
 185          //返回：无
 186          ///////////////////////////////////////////////
 187          void inter1_can_rxd( void ) interrupt 0
 188          {
 189   1              uchar state;
 190   1          uchar ID_M;
 191   1          uchar ID_L;
 192   1              uchar ID_R;
 193   1      
 194   1          EA = 0;             //关CPU中断
 195   1          IE0 = 0;    //由于是中断INT0是电平触发方式，所以需要软件将INT0的中断请求标志IE0清零
 196   1              ID_R = RBSR1;
 197   1          ID_M = RBSR2;
 198   1          ID_L = RBSR3;
 199   1      
 200   1              state = IR;     //IR为SJA1000的中断寄存器
 201   1      
 202   1              if( state & 0x01)
 203   1              {
 204   2                      RX_buffer_1[0] =  RBSR0;
 205   2                      RX_buffer_1[1] =  RBSR1;
 206   2                      RX_buffer_1[2] =  RBSR2;
 207   2                      RX_buffer_1[3] =  RBSR3;
 208   2                      RX_buffer_1[4] =  RBSR4;
 209   2                      RX_buffer_1[5] =  RBSR5;
 210   2                      RX_buffer_1[6] =  RBSR6;
 211   2      //              frog_light = 0;
 212   2      //              delay(10000);
 213   2      //              frog_light = 1;
 214   2      //              left_light = 0;//左转向灯
 215   2      //              backup_light = 0;//倒车灯
 216   2      //              stop_light   = 0;
 217   2                      interrupt_flag_1 = 1; //实际上也就这些寄存器中的数据有用，扩展的其他字节都是填写的无意义数据。
 218   2      
 219   2              }
 220   1              CMR = 0x04;             //CMR.2=1--接收完毕，释放接收缓冲器
 221   1              state = ALC;    //释放仲裁随时捕捉寄存器（读该寄存器即可）
 222   1              state = ECC;    //释放错误代码捕捉寄存器（读该寄存器即可）
 223   1              IER = 0x01;             // IER.0=1--接收中断使能
 224   1              EA = 1;                 //重新开启CPU中断
 225   1              EX0=1;
 226   1               
 227   1      }
 228          
 229          ///////////////////////////////////////////////
 230          //函数：can_rxd
 231          //说明：接收处理函数，根据接收处理子函数信息处理外部显示效果，点亮相应的LED灯。
 232          //入口：无
 233          //返回：无
 234          ///////////////////////////////////////////////
 235          void can_rxd(void)       //接收处理函数
 236          {       
 237   1              uchar control_light,light_state;
 238   1              control_light = RX_buffer_1[5]; //根据第六字节数据判断是何种灯。
 239   1              light_state = RX_buffer_1[6];
 240   1      //      stop_light = 0;
 241   1      //      delay(10000);
C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 5   

 242   1      //      stop_light =1;
 243   1      
 244   1              if (control_light == 0x03)
 245   1              {       
 246   2                      if(light_state == 0x01)
 247   2                      {
 248   3                              
 249   3                              
 250   3                              left_light = 0;//左转向开
 251   3      //                      delay(500000);
 252   3      //                      left_light = 1;
 253   3      //                      delay(500000);
 254   3                      
 255   3                              
 256   3                              interrupt_flag_1 = 0;
 257   3                              left_flag = 1;    }
 258   2                      
 259   2                      else
 260   2                      {
 261   3                              left_light = 1;//左转向关
 262   3                              interrupt_flag_1 = 0;
 263   3                              left_flag = 0;
 264   3                      }
 265   2                       }
 266   1              if (control_light == 0x04)
 267   1              {
 268   2                      if(light_state == 0x01)
 269   2                      {
 270   3                              backup_light = 0;//倒车灯开
 271   3                              interrupt_flag_1 = 0;
 272   3                      }else
 273   2                      {
 274   3                              backup_light = 1;//倒车灯关
 275   3                              interrupt_flag_1 = 0;
 276   3                      }
 277   2              }
 278   1              if (control_light == 0x05)
 279   1              {
 280   2                      if(light_state == 0x01)
 281   2                      {
 282   3                              frog_light = 0;//雾灯开
 283   3                              interrupt_flag_1 = 0;
 284   3                      }else
 285   2                      {
 286   3                              frog_light = 1;//雾灯关
 287   3                              interrupt_flag_1 = 0;
 288   3                      }
 289   2              }
 290   1              if (control_light == 0x06)
 291   1              {
 292   2                      if(light_state == 0x01)
 293   2                      {
 294   3                              stop_light = 0;//刹车灯开
 295   3                              interrupt_flag_1 = 0;
 296   3                      }else
 297   2                      {
 298   3                              stop_light = 1;//刹车灯关
 299   3                              interrupt_flag_1 = 0;
 300   3                      }
 301   2              }
 302   1      }
 303             
C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 6   

 304          
 305          ///////////////////////////////////////////////
 306          //函数：can_txd
 307          //说明：发送处理函数，获取执行效果信息之后返回相关信息给中心控制节点
 308          //入口：无
 309          //返回：无
 310          ///////////////////////////////////////////////
 311          void can_txd(void)  //发送处理函数
 312          {
 313   1              uchar state;
 314   1              uchar TX_buffer_1[ N_can ] ;    //N_can=13，TX_buffer数组为待传送的数据帧
 315   1              //初始化标示码头信息
 316   1          TX_buffer_1[0] = 0x82;      //.7=0--扩展帧；.6=0--数据帧; .0-.3=100--数据长度为8字节
 317   1          TX_buffer_1[1] = 0x02;      //本帧信息的ID    28~21   滤波器滤28~13的
 318   1          TX_buffer_1[2] = 0x01;        //20~13
 319   1          TX_buffer_1[3] = 0x10;         //12~5
 320   1          TX_buffer_1[4] = 0x00;         // 4~0
 321   1      
 322   1              complete_1 = 0;
 323   1              //初始化发送数据单元
 324   1              
 325   1              TX_buffer_1[5] = 0x01;  //源地址
 326   1              TX_buffer_1[6] = 0x10;
 327   1              state = SR;
 328   1              if(!(state & 0x10))
 329   1              {
 330   2                      if(state & 0x08)
 331   2                      {
 332   3                         if(state & 0x04)
 333   3                         {
 334   4                                      TBSR0  = TX_buffer_1[0];
 335   4                              TBSR1  = TX_buffer_1[1];
 336   4                              TBSR2  = TX_buffer_1[2];
 337   4                              TBSR3  = TX_buffer_1[3];
 338   4                              TBSR4  = TX_buffer_1[4];
 339   4                              TBSR5  = TX_buffer_1[5];
 340   4                              TBSR6  = TX_buffer_1[6];
 341   4                                      complete_1 = 1;
 342   4                              CMR = 0x01;     //置位发送请求
 343   4                         }
 344   3                      }
 345   2              }
 346   1      }
 347          
 348          
 349          
 350          ///////////////////////////////////////////////
 351          //函数：delay
 352          //说明：延时子函数
 353          //入口：uchar time:延时时间time us
 354          //返回：无
 355          ///////////////////////////////////////////////
 356          void delay(unsigned char time)
 357          {       
 358   1          unsigned char timeee;
 359   1          while(time--)
 360   1              {
 361   2                  timeee=0xFF;
 362   2                      while(timeee--);
 363   2              }
 364   1      }
 365          
C51 COMPILER V9.01   NODE1                                                                 09/06/2024 09:37:19 PAGE 7   

 366          ///////////////////////////////////////////////
 367          //函数：main
 368          //说明：主函数
 369          //入口：无
 370          //返回：无
 371          ///////////////////////////////////////////////
 372          void main(void)
 373          {
 374   1              init_mcu();
 375   1              init_sja1000();
 376   1      //      time0_init();
 377   1              while(1)
 378   1              {
 379   2      //              if(interrupt_flag_1)
 380   2      //              {       
 381   2              
 382   2                              can_rxd();
 383   2                              if(left_flag==1)
 384   2                              {
 385   3                                      left_light = 0;//左转向开
 386   3                                      delay(500000);
 387   3                                      left_light = 1;
 388   3                                      delay(500000);
 389   3                                      
 390   3                              }
 391   2                      }
 392   1              
 393   1      //               }
 394   1      }
 395          //       void time0() interrupt 1 
 396          //{
 397          //      static int i=0;
 398          //      uchar control_light,light_state;
 399          //      control_light = RX_buffer_1[5]; //根据第六字节数据判断是何种灯。
 400          //      light_state = RX_buffer_1[6];
 401          //      TH1=0XFC;       
 402          //      TL1=0X18;
 403          //                                                         g
 404          //      if(control_light == 0x04&&light_state == 0x01)
 405          //      {       i++;
 406          //              if(i=1000){
 407          //              backup_light = !backup_light;   
 408          //              i=0;}
 409          //              
 410          //      }                                               
 411          //}      


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    424    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
