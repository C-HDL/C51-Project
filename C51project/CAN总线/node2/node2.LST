C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NODE2
OBJECT MODULE PLACED IN node2.OBJ
COMPILER INVOKED BY: E:\keilc51\C51\BIN\C51.EXE node2.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          #define uchar   unsigned char   //宏定义
   5          #define uint    unsigned int    //宏定义
   6          
   7          #define N_can   13      //N_can代表一帧字节数
   8          
   9          bit left_flag = 0;
  10          
  11          uchar TX_buffer_1[13]; //接收的13个字节数据（//发送的数据）
  12          uchar RX_buffer_1[13]; //接收的13个字节数据
  13          
  14          sbit SJA_CS  = P2^0; //SJA1000片选管脚，低电平有效
  15          sbit SJA_RST = P2^7;//SJA1000复位管脚
  16          
  17          sbit high_beam = P1^0;//远光灯灯
  18          sbit dipped_beam = P1^1;//近光灯
  19          
  20          
  21          uchar complete_1;
  22          
  23          bit interrupt_flag_1 = 0;
  24          /*CAN总线SJA1000寄存器地址定义（用的是PeliCAN模式，扩展帧EFF模式）*/
  25          //xdata ----> 可寻址片外ram (64k地址范围:0000H-FFFFH)
  26          
  27          uchar   xdata    MODR     _at_   0xFE00;        // 模式寄存器
  28          uchar   xdata    CMR      _at_   0xFE01;        // 命令寄存器
  29          uchar   xdata    SR           _at_   0xFE02;    // 状态寄存器
  30          uchar   xdata    IR               _at_   0xFE03;        // 中断寄存器
  31          uchar   xdata    IER      _at_   0xFE04;        // 中断使能寄存器
  32          
  33          uchar   xdata    BTR0     _at_   0xFE06;        // 总线定时寄存器0 ；总线波特率的选择
  34          uchar   xdata    BTR1     _at_   0xFE07;        // 总线定时寄存器1 ；总线波特率的选择
  35          uchar   xdata    OCR      _at_   0xFE08;        // 输出控制寄存器       汇编 1a
  36          
  37                  // 验收代码寄存器（16-19）
  38          uchar   xdata    ACR0     _at_   0xFE10;//16;
  39          uchar   xdata    ACR1     _at_   0xFE11;//17;
  40          uchar   xdata    ACR2     _at_   0xFE12;//18;
  41          uchar   xdata    ACR3     _at_   0xFE13;//19;
  42          
  43                  // 验收屏蔽寄存器（20-23）
  44          uchar   xdata    AMR0     _at_   0xFE14;//20;
  45          uchar   xdata    AMR1     _at_   0xFE15;//21;
  46          uchar   xdata    AMR2     _at_   0xFE16;//22;
  47          uchar   xdata    AMR3     _at_   0xFE17;//23;
  48          
  49          uchar   xdata    CDR      _at_   0xFE1F;//31;   // 时钟分频器            C8
  50          uchar   xdata    ALC      _at_   0xFE0B;//11;   // 仲裁丢失捕捉寄存器
  51          uchar   xdata    ECC      _at_   0xFE0C;//12;   // 误码捕捉寄存器
  52          
  53                  // 发送缓冲器地址(16-28)
  54          uchar   xdata    TBSR0    _at_   0xFE10;//16;//TX帧信息
  55          uchar   xdata    TBSR1    _at_   0xFE11;//17;//TX识别码1 (ID.21-ID.28)
C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 2   

  56          uchar   xdata    TBSR2    _at_   0xFE12;//18;//TX识别码2 (ID.13-ID.20)
  57          uchar   xdata    TBSR3    _at_   0xFE13;//19;//TX识别码3 (ID.5-ID.12)
  58          uchar   xdata    TBSR4    _at_   0xFE14;//20;//TX识别码4（高5位是ID.0-ID.4）
  59          uchar   xdata    TBSR5    _at_   0xFE15;//21;//数据1
  60          uchar   xdata    TBSR6    _at_   0xFE16;//22;//数据2
  61          uchar   xdata    TBSR7    _at_   0xFE17;//23;//数据3
  62          uchar   xdata    TBSR8    _at_   0xFE18;//24;//数据4
  63          uchar   xdata    TBSR9    _at_   0xFE19;//25;//数据5
  64          uchar   xdata    TBSR10   _at_   0xFE1A;//26;//数据6
  65          uchar   xdata    TBSR11   _at_   0xFE1B;//27;//数据7
  66          uchar   xdata    TBSR12   _at_   0xFE1C;//28;//数据8
  67          
  68          // 接收缓冲器地址(16-28)
  69          uchar   xdata    RBSR0    _at_   0xFE10;//16;
  70          uchar   xdata    RBSR1    _at_   0xFE11;//17;
  71          uchar   xdata    RBSR2    _at_   0xFE12;//18;
  72          uchar   xdata    RBSR3    _at_   0xFE13;//19;
  73          uchar   xdata    RBSR4    _at_   0xFE14;//20;
  74          uchar   xdata    RBSR5    _at_   0xFE15;//21;
  75          uchar   xdata    RBSR6    _at_   0xFE16;//22;
  76          uchar   xdata    RBSR7    _at_   0xFE17;//23;
  77          uchar   xdata    RBSR8    _at_   0xFE18;//24;
  78          uchar   xdata    RBSR9    _at_   0xFE19;//25;
  79          uchar   xdata    RBSR10   _at_   0xFE1A;//26;
  80          uchar   xdata    RBSR11   _at_   0xFE1B;//27;
  81          uchar   xdata    RBSR12   _at_   0xFE1C;//28;
  82            
  83          /*子函数声明*/
  84          void init_mcu(void);  //MCU初始化
  85          void init_sja1000(void);        //SJA1000初始化
  86          void can_txd(void);  //发送处理函数
  87          void can_rxd(void);      //接收处理函数
  88          void delay(uchar);       //延迟 
  89          
  90          ///////////////////////////////////////////////
  91          //函数：init_mcu
  92          //说明：单片机I/O口初始化
  93          //              主要是各中断寄存器的初始化
  94          //入口：无
  95          //返回：无
  96          ///////////////////////////////////////////////
  97          void init_mcu(void)
  98          {
  99   1          SJA_RST = 0;
 100   1              delay(10);
 101   1          SJA_RST = 1;//CAN总线复位管脚
 102   1              SJA_CS = 0;             //CAN总线片选有效
 103   1          IT0 = 0;    //MCU外部中断INT0设置为 低电平 触发
 104   1          EX0 = 1;    //开MCU外部中断INT0
 105   1          EA = 1;     //开MCU总中断   
 106   1      }
 107          
 108          ///////////////////////////////////////////////
 109          //函数：init_sja1000
 110          //说明：独立CAN控制器SJA1000的初始化
 111          //入口：无
 112          //返回：无
 113          ///////////////////////////////////////////////
 114          void init_sja1000(void)
 115          {
 116   1      //uchar state;
 117   1          uchar ACRR[4];
C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 3   

 118   1          uchar AMRR[4];
 119   1      /*原有代码
 120   1      // 接收代码寄存器                                                            
 121   1          ACRR[0] = 0x20;
 122   1          ACRR[1] = 0x00;
 123   1          ACRR[2] = 0x10;
 124   1          ACRR[3] = 0x00;
 125   1      // 接收屏蔽寄存器
 126   1          AMRR[0] = 0x3f;
 127   1          AMRR[1] = 0Xff;
 128   1          AMRR[2] = 0xf8;
 129   1          AMRR[3] = 0x07;
 130   1      原有代码*/
 131   1          ACRR[0] = 0xff;
 132   1          ACRR[1] = 0x03;//本节点编号03
 133   1          ACRR[2] = 0xff;
 134   1          ACRR[3] = 0xff;//接收代码寄存器
 135   1      
 136   1          AMRR[0] = 0xff;
 137   1          AMRR[1] = 0x00;
 138   1          AMRR[2] = 0xff;
 139   1          AMRR[3] = 0xff;//接收屏蔽寄存器，只接收发往本节点的报文
 140   1              MODR  = 0x09;   // 设置MOD.0=1--进入复位模式，以便设置相应的寄存器
 141   1      
 142   1      
 143   1      
 144   1      // 对SJA1000部分寄存器进行初始化设置
 145   1          CDR  = 0xC8;        // CDR为时钟分频器，CDR.3=1--时钟关闭, CDR.7=0---basic CAN, CDR.7=1---Peli CAN
 146   1          BTR0 = 0x01;        // 总线定时寄存器0 ；总线波特率设定
 147   1          BTR1 = 0x1B;        // 总线定时寄存器1 ；总线波特率设定
 148   1          IER  = 0x01;        // IER.0=1--接收中断使能；  IER.1=0--关闭发送中断使能
 149   1          OCR  = 0x1a;        // 配置输出控制寄存器
 150   1          CMR  = 0x04;        // 释放接收缓冲器
 151   1      
 152   1      // 初始化接收代码寄存器
 153   1          ACR0 = ACRR[0];
 154   1          ACR1 = ACRR[1];
 155   1          ACR2 = ACRR[2];
 156   1          ACR3 = ACRR[3]; 
 157   1      
 158   1      // 初始化接收屏蔽寄存器
 159   1          AMR0 = AMRR[0];
 160   1          AMR1 = AMRR[1];
 161   1          AMR2 = AMRR[2];
 162   1          AMR3 = AMRR[3]; 
 163   1      
 164   1              MODR   = 0x08;  //MOD.3=0--双滤波器模式
 165   1      
 166   1      }
 167          
 168          ///////////////////////////////////////////////
 169          //函数：inter1_can_rxd  (外部中断INT0)
 170          //说明：接收数据函数，在中断服务程序中调用
 171          //入口：无
 172          //返回：无
 173          ///////////////////////////////////////////////
 174          void inter1_can_rxd( void ) interrupt 0
 175          {
 176   1              uchar state;
 177   1          uchar ID_M;
 178   1          uchar ID_L;
 179   1              uchar ID_R;
C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 4   

 180   1      
 181   1          EA = 0;             //关CPU中断
 182   1          IE0 = 0;    //由于是中断INT0是电平触发方式，所以需要软件将INT0的中断请求标志IE0清零
 183   1              ID_R = RBSR1;
 184   1          ID_M = RBSR2;
 185   1          ID_L = RBSR3;
 186   1      
 187   1              state = IR;     //IR为SJA1000的中断寄存器
 188   1      
 189   1              if( state & 0x01)
 190   1              {
 191   2                      RX_buffer_1[0] =  RBSR0;
 192   2              RX_buffer_1[1] =  RBSR1;
 193   2                      RX_buffer_1[2] =  RBSR2;
 194   2              RX_buffer_1[3] =  RBSR3;
 195   2              RX_buffer_1[4] =  RBSR4;
 196   2              RX_buffer_1[5] =  RBSR5;
 197   2              RX_buffer_1[6] =  RBSR6;
 198   2                       //实际上也就这些寄存器中的数据有用，扩展的其他字节都是填写的无意义数据。
 199   2              }
 200   1              CMR = 0x04;             //CMR.2=1--接收完毕，释放接收缓冲器
 201   1              state = ALC;    //释放仲裁随时捕捉寄存器（读该寄存器即可）
 202   1              state = ECC;    //释放错误代码捕捉寄存器（读该寄存器即可）
 203   1              IER = 0x01;             // IER.0=1--接收中断使能
 204   1              EA = 1;                 //重新开启CPU中断
 205   1              EX0=1;
 206   1               
 207   1      }
 208          
 209          ///////////////////////////////////////////////
 210          //函数：can_rxd
 211          //说明：接收处理函数，根据接收处理子函数信息处理外部显示效果，点亮相应的LED灯。
 212          //入口：无
 213          //返回：无
 214          ///////////////////////////////////////////////
 215          void can_rxd(void)       //接收处理函数
 216          {
 217   1              uchar control_light,light_state;
 218   1              control_light = RX_buffer_1[5]; //根据第六字节数据判断是何种灯。
 219   1              light_state = RX_buffer_1[6];
 220   1              if (control_light == 0x01)
 221   1              {       
 222   2                      if(light_state == 0x01)
 223   2                      {
 224   3                              high_beam = 0;//远光灯开
 225   3                              interrupt_flag_1 = 0;
 226   3                              left_flag = 1;
 227   3                      }else
 228   2                      {
 229   3                              high_beam = 1;//远光灯关
 230   3                              interrupt_flag_1 = 0;
 231   3                              left_flag = 0;
 232   3                      }
 233   2              }
 234   1              if (control_light == 0x02)
 235   1              {
 236   2                      if(light_state == 0x01)
 237   2                      {
 238   3                              dipped_beam = 0;//近光灯开
 239   3                              interrupt_flag_1 = 0;
 240   3                      }else
 241   2                      {
C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 5   

 242   3                              dipped_beam = 1;//近光灯关
 243   3                              interrupt_flag_1 = 0;
 244   3                      }
 245   2              }
 246   1      /*      
 247   1              if (control_light == 0x03)
 248   1              {
 249   1                      if(light_state == 0x01)
 250   1                      {
 251   1                              frog_light = 0;//雾灯开
 252   1                              interrupt_flag_1 = 0;
 253   1                      }else
 254   1                      {
 255   1                              frog_light = 1;//雾灯关
 256   1                              interrupt_flag_1 = 0;
 257   1                      }
 258   1              }
 259   1              if (control_light == 0x04)
 260   1              {
 261   1                      if(light_state == 0x01)
 262   1                      {
 263   1                              stop_light = 0;//刹车灯开
 264   1                              interrupt_flag_1 = 0;
 265   1                      }else
 266   1                      {
 267   1                              frog_light = 1;//刹车灯关
 268   1                              interrupt_flag_1 = 0;
 269   1                      }
 270   1              }
 271   1      */
 272   1      }
 273          
 274          
 275          ///////////////////////////////////////////////
 276          //函数：can_txd
 277          //说明：发送处理函数，获取执行效果信息之后返回相关信息给中心控制节点
 278          //入口：无
 279          //返回：无
 280          ///////////////////////////////////////////////
 281          void can_txd(void)  //发送处理函数
 282          {
 283   1              uchar state;
 284   1              uchar TX_buffer_1[ N_can ] ;    //N_can=13，TX_buffer数组为待传送的数据帧
 285   1              //初始化标示码头信息
 286   1          TX_buffer_1[0] = 0x82;      //.7=0--扩展帧；.6=0--数据帧; .0-.3=100--数据长度为8字节
 287   1          TX_buffer_1[1] = 0x03;      //本帧信息的ID    28~21   滤波器滤28~13的
 288   1          TX_buffer_1[2] = 0x01;        //20~13
 289   1          TX_buffer_1[3] = 0x10;         //12~5
 290   1          TX_buffer_1[4] = 0x00;         // 4~0
 291   1      
 292   1              complete_1 = 0;
 293   1              //初始化发送数据单元
 294   1      
 295   1              TX_buffer_1[5] = 0x03;  //源地址
 296   1              TX_buffer_1[6] = 0x30;
 297   1              state = SR;
 298   1              if(!(state & 0x10))
 299   1              {
 300   2                      if(state & 0x08)
 301   2                      {
 302   3                         if(state & 0x04)
 303   3                         {
C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 6   

 304   4                                      TBSR0  = TX_buffer_1[0];
 305   4                              TBSR1  = TX_buffer_1[1];
 306   4                              TBSR2  = TX_buffer_1[2];
 307   4                              TBSR3  = TX_buffer_1[3];
 308   4                              TBSR4  = TX_buffer_1[4];
 309   4                              TBSR5  = TX_buffer_1[5];
 310   4                              TBSR6  = TX_buffer_1[6];
 311   4                                      complete_1 = 1;
 312   4                              CMR = 0x01;     //置位发送请求
 313   4                         }
 314   3                      }
 315   2              }
 316   1      }
 317          
 318          
 319          
 320          ///////////////////////////////////////////////
 321          //函数：delay
 322          //说明：延时子函数
 323          //入口：uchar time:延时时间time us
 324          //返回：无
 325          ///////////////////////////////////////////////
 326          void delay(unsigned char time)
 327          {       
 328   1          unsigned char timeee;
 329   1          while(time--)
 330   1              {
 331   2                  timeee=0xFF;
 332   2                      while(timeee--);
 333   2              }
 334   1      }
 335          
 336          ///////////////////////////////////////////////
 337          //函数：main
 338          //说明：主函数
 339          //入口：无
 340          //返回：无
 341          ///////////////////////////////////////////////
 342          void main(void)
 343          {
 344   1              init_mcu();
 345   1              init_sja1000();
 346   1      
 347   1              while(1)
 348   1              {
 349   2                      if(interrupt_flag_1)
 350   2                      {
 351   3                              can_rxd();
 352   3                      }
 353   2              }       
 354   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    376    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.01   NODE2                                                                 09/04/2024 10:52:32 PAGE 7   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
